# Stage 6

Заполнил базу 1 миллионом записей. Результаты профилирования:

[Allocation profile](alloc.html)

100% аллоков занимает метод `HttpServer.handleRequest`, внутри которого происходит вся обработка входящего запроса:

- 71% всех аллоков ушло на `ChunkedResponseSender.generateDataChunkAndWrite`, внутри которого данные переводятся в байты
и отправляются на выход
  - 40% ушло на `ByteArrayBuilder.<init>` - необходим для упорядоченной отправки данных по частям (хедеры, kv-пары данных, конечный пустой чанк данных)
  - 14% ушло на `Session.write`
- 29% на `MergingEntryIterator.next` - достает входящие kv-пары данных

[CPU profile](cpu.html)

- 63.24% процессорного времени занимает `ChunkedResponseSender.generateDataChunkAndWrite`
  - 56% - `Session.write`
- 34.78% процессорного времени занимает `MergingEntryIterator.next`
- 1.58% ушло на GC

[Lock profile](lock.html)

Профиль локов пустой - подозреваю, это потому что в момент снятия профиляции не было локов при работе range-запроса. 
Скорее всего в рамках range-запросов нет (или очень мало) блокировок

### Выводы

Был реализован range-метод, который отправляет респонс чанками. Сама чанковая отправка ответа подразумевает наличие
чанка хедеров, чанков данных и чанка окончания респонса. Для того, чтобы отправка данных осуществлялась строго по
чанкам, в `session.write` отправляются массивы байтов определенных чанков, которые были созданы `ByteArrayBuilder'ом`,
из-за чего появляются лишние аллокации, т.к. инстанс билдера создается для каждого чанка данных. В основном, за 
исключением `ByteArrayBuilder`, ресурсы уходят на `Session.write` и `MergingEntryIterator.next`
